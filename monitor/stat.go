package monitor

import (
	"fmt"
	"sort"
	"sync"
	"time"
)

const NORMAL_REQ = 500

type LatencyStats struct {
	// 增加begin，end信息，便于计算压测速率信息
	// begin： 压测开始时间
	// end：压测结束时间
	begin, end time.Time

	// 统计成功次数，失败次数
	succ, fail int

	// 总压测次数
	num int

	mark time.Time

	// 总时延，最小时延，最大时延
	dur, min, max time.Duration

	// 互斥锁，保证互操作时 goroutine 并发安全
	mu *sync.Mutex

	// 附加信息，便于最后统计汇总
	ext string

	percentile [NORMAL_REQ]int

	longreq []int
}

func New(ext string) *LatencyStats {
	s := &LatencyStats{
		ext: ext,
		mu:  &sync.Mutex{},
		percentile: [NORMAL_REQ]int{},
		longreq: []int{},
	}
	return s
}

func (s *LatencyStats) Start() {
	s.mark = time.Now()
	if s.begin.IsZero() {
		s.begin = s.mark
	}
}

func (s LatencyStats) String() string {
	return fmt.Sprintf("begin: %v, end: %v, succ: %v, fail :%v, max-latency: %v, min-latency: %v",
		s.begin.UnixNano(), s.end.UnixNano(), s.succ, s.fail, s.max, s.fail)
}

func (s *LatencyStats) record(n int) {

	if s.mark.IsZero() {
		panic("not started")
	}

	now := time.Now()
	s.end = now
	dur := now.Sub(s.mark)
	dur1 := dur / time.Duration(n)
	if dur1 < s.min || s.min == 0 {
		s.min = dur1
	}
	if dur1 > s.max {
		s.max = dur1
	}
	s.dur += dur
	s.num += n
	ms := int(dur1 / time.Millisecond)
	if ms < NORMAL_REQ {
		s.percentile[ms]++
	} else {
		s.longreq = append(s.longreq, ms)
	}
	s.mark = time.Time{}
}

func (s *LatencyStats) RecordSucc(n int) {
	s.record(n)
	s.succ += n
}

func (s *LatencyStats) RecordFail(n int) {
	s.record(n)
	s.fail += n
}

func (s *LatencyStats) RatePerSec() int {
	durSec := s.dur / time.Second
	if durSec > 0 {
		return s.num / int(durSec)
	}
	return s.num
}

func (s *LatencyStats) Avg() time.Duration {
	if s.num > 0 {
		return s.dur / time.Duration(s.num)
	}
	return 0
}

func (s *LatencyStats) TPS() int {
	lat := s.end.Sub(s.begin)
	return int(float64(s.succ) / float64(lat) * float64(time.Second))
}

func (s *LatencyStats) Pct(p int) string {
	n := s.num * p / 100
	i := 0
	t := 0
	for i < NORMAL_REQ && t < n {
		t += s.percentile[i]
		i += 1
	}
	if t >= n {
		return fmt.Sprintf("< %dms", i + 1)
	} else {
		sort.Ints(s.longreq)
		if len(s.longreq) > n - t {
			return fmt.Sprintf("< %dms", s.longreq[n - t] + 1)
		} else {
			return "NaN"
		}
	}
}

func (s *LatencyStats) Add(x *LatencyStats) {
	s.mu.Lock()
	defer func() {
		s.mu.Unlock()
	}()

	if s.ext == "" {
		s.ext = x.ext
	}
	if s.begin.UnixNano() > x.begin.UnixNano() {
		s.begin = x.begin
	}
	if s.end.IsZero() || s.end.UnixNano() < x.end.UnixNano() {
		s.end = x.end
	}

	if x.min < s.min || s.min == 0 {
		s.min = x.min
	}
	if x.max > s.max {
		s.max = x.max
	}
	s.dur += x.dur
	s.num += x.num

	s.succ += x.succ
	s.fail += x.fail

	for i:=0; i<NORMAL_REQ; i++ {
		s.percentile[i] += x.percentile[i]
	}
	s.longreq = append(s.longreq, x.longreq...)
}

// Merge merge multiple LatencyStats(chan *LatencyStats) generated by goroutines and return one LatencyStats
func Merge(s chan *LatencyStats) *LatencyStats {

	x := New("")
	x.Start()

	for i := range s {
		x.Add(i)
	}

	return x
}
